{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Multi-Tenant ChromaDB Foundation",
        "description": "Implementar ChromaDB collections per-user con metadata filtering",
        "details": "Extender ChromaManager existente para crear collections \"user_{user_id}\" garantizando aislamiento completo. Implementar metadata filtering para data types: conversation, document, preference. Asegurar que usuario A nunca pueda acceder datos de usuario B.",
        "testStrategy": "Tests unitarios aislamiento per-user, tests integración metadata filtering, tests seguridad cross-user access",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "BaseModularAgent Interface Design",
        "description": "Crear interface foundation estable para agentes modulares componibles",
        "details": "Diseñar BaseModularAgent Protocol con métodos: execute(input_data, context) -> AgentResult, get_capabilities() -> List[str], can_handle(task_type) -> bool. CRÍTICO: Interface debe ser estable desde inicio para evitar refactoring masivo.",
        "testStrategy": "Tests interface compliance, tests abstract methods, mock implementations para validation",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "VectorMemoryManager Per-User",
        "description": "Implementar VectorMemoryManager básico para contexto persistente por usuario",
        "details": "Crear manager que maneje embeddings y búsquedas vectoriales per-user usando collections ChromaDB. Funcionalidades: store_context, retrieve_context, search_similar. Integrar con Redis session memory existente.",
        "testStrategy": "Tests persistencia vectorial, tests búsqueda semántica, tests integración Redis",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Data Migration Script",
        "description": "Migrar data existente de collection única a collections per-user",
        "details": "Script para migrar data de \"telegram_data\" collection existente a collections \"user_{user_id}\". Incluir validation de integridad, rollback capabilities, dry-run mode. Preservar metadata y embeddings existentes.",
        "testStrategy": "Tests migration script, tests integridad data, tests rollback functionality",
        "status": "pending",
        "dependencies": [
          1,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "FileHandlerAgent Implementation",
        "description": "Implementar FileHandlerAgent completo con validación y parsing seguro",
        "details": "Crear agente modular para manejo de archivos: validación tipos, límites tamaño, content validation, parsing documents (PDF, DOCX, etc.). Implementar BaseModularAgent interface. Incluir security validations y error handling robusto.",
        "testStrategy": "Tests validación security, tests parsing diferentes formatos, tests boundary conditions",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "NLPParserAgent Implementation",
        "description": "Implementar NLPParserAgent básico con intent recognition y entity extraction",
        "details": "Crear agente para procesamiento lenguaje natural: intent recognition, entity extraction, context understanding. Implementar BaseModularAgent interface. Integrar con LLMs existentes para parsing de comandos complejos.",
        "testStrategy": "Tests intent recognition accuracy, tests entity extraction, tests integration con LLMs",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Sequential Execution Workflows",
        "description": "Implementar workflows de ejecución secuencial entre agentes modulares",
        "details": "Crear sistema simple de ejecución secuencial FileHandlerAgent → NLPParserAgent. NO implementar composition engine complejo aún. Focus en validar que agentes individuales funcionan perfectamente en pipeline simple.",
        "testStrategy": "Tests integration pipeline FileHandler → NLP, tests error propagation, tests context passing",
        "status": "pending",
        "dependencies": [
          5,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Performance Testing Collections Per-User",
        "description": "Validar performance de collections per-user vs collection única",
        "details": "Tests de performance para determinar si approach de collections per-user escala correctamente. Medir query latency, memory usage, concurrent user scenarios. Decision point para collections granulares si performance insufficient.",
        "testStrategy": "Load tests multiple users, performance benchmarks, memory profiling, concurrent access tests",
        "status": "pending",
        "dependencies": [
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "SimpleComposer Configuration-Driven",
        "description": "Implementar SimpleComposer para composition básica de agentes",
        "details": "Crear SimpleComposer configuration-driven (NO dynamic orchestration). WORKFLOWS = {\"file_analysis\": [FileHandlerAgent, NLPParserAgent], \"chat\": [NLPParserAgent]}. Método compose_for_task() y execute_workflow() simple.",
        "testStrategy": "Tests configuration-driven workflows, tests compose logic, tests workflow execution",
        "status": "pending",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Hybrid Memory Integration",
        "description": "Integrar memoria híbrida Redis + ChromaDB completamente",
        "details": "Redis para session memory (1h TTL), ChromaDB para contexto largo plazo. Implementar context retrieval optimization, consistency entre ambos sistemas, memoria conversacional bidireccional completa.",
        "testStrategy": "Tests híbridos Redis+ChromaDB, tests consistency, tests context retrieval optimization",
        "status": "pending",
        "dependencies": [
          3,
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "E2E Testing & Validation",
        "description": "Suite completa E2E testing para workflows completos Fase 3C",
        "details": "E2E tests completos: usuario interactúa → agentes modulares → Vector DB mantiene contexto → agentes se combinan dinámicamente. Validar DoD Fase 3C completamente. Mantener 85%+ coverage.",
        "testStrategy": "E2E automation tests, coverage report 85%+, integration con CI existente, DoD validation",
        "status": "pending",
        "dependencies": [
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Collections Granulares Decision Point",
        "description": "Decision point: evaluar si collections granulares son necesarias",
        "details": "Basado en performance data de task #8, decidir si necesitamos collections granulares: \"user_123_conversations\", \"user_123_documents\". Solo implementar si performance testing demuestra necesidad real. Evitar premature optimization.",
        "testStrategy": "Analysis performance data, decision documentation, implementation solo si justified",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Sistema de Roles y Permisos",
        "description": "Implementar sistema de roles y permisos básico para ChromaDB multi-tenant",
        "details": "Incluir UserRole enum (USER, ADMIN, SUPER_ADMIN), Permission enum, RoleManager class con check_permission y grant_role. Integrar con ChromaManager existente manteniendo filosofía de simplicidad del proyecto.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Collections Globales Manager",
        "description": "Implementar GlobalCollectionManager para collections compartidas entre usuarios",
        "details": "Crear sistema de collections globales con naming convention 'global_{name}', RESERVED_COLLECTIONS dict, métodos create_global_collection, query_global_collection y contribute_to_global. Integrar con sistema de permisos.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Smart Content Analyzer",
        "description": "Sistema de análisis semántico para filtrado inteligente de contenido",
        "details": "Implementar SmartContentAnalyzer con ContentAnalysis dataclass, métodos analyze_user_message, extract_key_information y should_store_interaction. Incluir SKIP_PATTERNS e IMPORTANT_PATTERNS. Integrar con save_user_data_smart.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Hybrid Memory Manager",
        "description": "Gestión de memoria híbrida local/cloud con estrategias configurables",
        "details": "Implementar HybridMemoryManager con StorageStrategy enum (LOCAL_ONLY, CLOUD_ONLY, HYBRID, AUTO), cache local simple, métodos store_with_strategy y query_hybrid. Configuración per environment en settings.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "15"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Cross-Tenant Access Manager",
        "description": "Sistema de acceso controlado entre collections de diferentes usuarios",
        "details": "Implementar CrossTenantAccess con métodos grant_collection_access y query_with_cross_tenant_access. Security model con metadata tracking, permisos explícitos y accesos expirables. Incluir validación de roles.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "13",
          "14"
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-25T18:27:06.912Z",
      "updated": "2025-08-26T00:36:30.662Z",
      "description": "Tasks for master context"
    }
  }
}