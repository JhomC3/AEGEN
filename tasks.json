{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Multi-Tenant ChromaDB Foundation",
        "description": "Implementar ChromaDB collections per-user con metadata filtering",
        "details": "Extender ChromaManager existente para crear collections \"user_{user_id}\" garantizando aislamiento completo. Implementar metadata filtering para data types: conversation, document, preference. Asegurar que usuario A nunca pueda acceder datos de usuario B.",
        "testStrategy": "Tests unitarios aislamiento per-user, tests integración metadata filtering, tests seguridad cross-user access",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "BaseModularAgent Interface Design",
        "description": "Crear interface foundation estable para agentes modulares componibles",
        "details": "Diseñar BaseModularAgent Protocol con métodos: execute(input_data, context) -> AgentResult, get_capabilities() -> List[str], can_handle(task_type) -> bool. CRÍTICO: Interface debe ser estable desde inicio para evitar refactoring masivo.",
        "testStrategy": "Tests interface compliance, tests abstract methods, mock implementations para validation",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "VectorMemoryManager Per-User",
        "description": "Implementar VectorMemoryManager básico para contexto persistente por usuario",
        "details": "Crear manager que maneje embeddings y búsquedas vectoriales per-user usando collections ChromaDB. Funcionalidades: store_context, retrieve_context, search_similar. Integrar con Redis session memory existente.",
        "testStrategy": "Tests persistencia vectorial, tests búsqueda semántica, tests integración Redis",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "FileHandlerAgent Implementation",
        "description": "Implementar FileHandlerAgent completo con validación y parsing seguro",
        "details": "Crear agente modular para manejo de archivos: validación tipos, límites tamaño, content validation, parsing documents (PDF, DOCX, etc.). Implementar BaseModularAgent interface. Incluir security validations y error handling robusto.",
        "testStrategy": "Tests validación security, tests parsing diferentes formatos, tests boundary conditions",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "NLPParserAgent Implementation",
        "description": "Implementar NLPParserAgent básico con intent recognition y entity extraction",
        "details": "CANCELADO: Enhanced FunctionCallingRouter integra funcionalidad NLP directamente con structured output, eliminando 445 líneas de código duplicado. Análisis experto confirma que separación no aporta valor arquitectónico.",
        "testStrategy": "N/A - funcionalidad integrada en Enhanced Router",
        "status": "cancelled",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Sequential Execution Workflows",
        "description": "Implementar workflows de ejecución secuencial entre agentes modulares",
        "details": "COMPLETADO VÍA ENHANCED ROUTER: Enhanced FunctionCallingRouter implementa routing inteligente structured output con FileHandlerAgent integration. Elimina necesidad de pipeline manual FileHandler → NLP con arquitectura más robusta y determinística.",
        "testStrategy": "Tests completados vía Enhanced Router implementation - routing structured + entity extraction + intent classification",
        "status": "done",
        "dependencies": [
          5,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Performance Testing Collections Per-User",
        "description": "Validar performance de collections per-user vs collection única",
        "details": "Tests de performance para determinar si approach de collections per-user escala correctamente. Medir query latency, memory usage, concurrent user scenarios. Decision point para collections granulares si performance insufficient.",
        "testStrategy": "Load tests multiple users, performance benchmarks, memory profiling, concurrent access tests",
        "status": "done",
        "dependencies": [
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "SimpleComposer Configuration-Driven",
        "description": "Implementar SimpleComposer para composition básica de agentes",
        "details": "COMPLETADO: La funcionalidad de composición ahora es manejada por el EnhancedFunctionCallingRouter, que orquesta dinámicamente los agentes. Esto elimina la necesidad de un compositor estático y proporciona una solución más flexible y robusta.",
        "testStrategy": "Validado a través de las pruebas del EnhancedFunctionCallingRouter.",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Hybrid Memory Integration",
        "description": "Integrar memoria híbrida Redis + ChromaDB completamente",
        "details": "COMPLETADO: Se ha solucionado la cascada de errores que impedía la correcta interacción entre la memoria de sesión (Redis) y la memoria a largo plazo (ChromaDB). El session_id ahora se propaga correctamente, asegurando la consistencia y la recuperación del contexto.",
        "testStrategy": "Validado a través de la depuración y las pruebas de interacción con el bot.",
        "status": "done",
        "dependencies": [
          3,
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "E2E Testing & Validation",
        "description": "Suite completa E2E testing para workflows completos Fase 3C",
        "details": "E2E tests completos: usuario interactúa → agentes modulares → Vector DB mantiene contexto → agentes se combinan dinámicamente. Validar DoD Fase 3C completamente. Mantener 85%+ coverage.",
        "testStrategy": "E2E automation tests, coverage report 85%+, integration con CI existente, DoD validation",
        "status": "pending",
        "dependencies": [
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Collections Granulares Decision Point",
        "description": "Decision point: evaluar si collections granulares son necesarias",
        "details": "Basado en performance data de task #8, decidir si necesitamos collections granulares: \"user_123_conversations\", \"user_123_documents\". Solo implementar si performance testing demuestra necesidad real. Evitar premature optimization.",
        "testStrategy": "Analysis performance data, decision documentation, implementation solo si justified",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Sistema de Roles y Permisos",
        "description": "Implementar sistema de roles y permisos básico para ChromaDB multi-tenant",
        "details": "Incluir UserRole enum (USER, ADMIN, SUPER_ADMIN), Permission enum, RoleManager class con check_permission y grant_role. Integrar con ChromaManager existente manteniendo filosofía de simplicidad del proyecto.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Collections Globales Manager",
        "description": "Implementar GlobalCollectionManager para collections compartidas entre usuarios",
        "details": "Crear sistema de collections globales con naming convention 'global_{name}', RESERVED_COLLECTIONS dict, métodos create_global_collection, query_global_collection y contribute_to_global. Integrar con sistema de permisos.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Smart Content Analyzer",
        "description": "Sistema de análisis semántico para filtrado inteligente de contenido",
        "details": "Implementar SmartContentAnalyzer con ContentAnalysis dataclass, métodos analyze_user_message, extract_key_information y should_store_interaction. Incluir SKIP_PATTERNS e IMPORTANT_PATTERNS. Integrar con save_user_data_smart.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Hybrid Memory Manager",
        "description": "Gestión de memoria híbrida local/cloud con estrategias configurables",
        "details": "Implementar HybridMemoryManager con StorageStrategy enum (LOCAL_ONLY, CLOUD_ONLY, HYBRID, AUTO), cache local simple, métodos store_with_strategy y query_hybrid. Configuración per environment en settings.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "15"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Cross-Tenant Access Manager",
        "description": "Sistema de acceso controlado entre collections de diferentes usuarios",
        "details": "Implementar CrossTenantAccess con métodos grant_collection_access y query_with_cross_tenant_access. Security model con metadata tracking, permisos explícitos y accesos expirables. Incluir validación de roles.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "13",
          "14"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Depuración y Estabilización del Orquestador",
        "description": "Realizar una depuración profunda del flujo de orquestación para resolver una cascada de errores críticos.",
        "details": "Se identificó y solucionó una cascada de errores interconectados que incluían: 1) Fallo en el registro del ChatSpecialist. 2) Manejo de errores de API inexistente en el router. 3) Lógica de inicialización de sesión rota para nuevos usuarios. 4) Errores de importación circular. La solución integral restauró la estabilidad del sistema.",
        "testStrategy": "Validado a través de múltiples ciclos de depuración, análisis de logs y pruebas de interacción en vivo.",
        "status": "done",
        "dependencies": [10],
        "priority": "critical",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Restauración Funcionalidad ChatAgent ADR-0009",
        "description": "Restauración completa funcionalidad ChatAgent perdida durante optimización performance",
        "details": "COMPLETADO: Restauración 100% exitosa de funcionalidad ChatAgent (143→628 líneas). Implementado ADR-0009 con arquitectura híbrida que mantiene performance optimizations (function calling <2s) + funcionalidad completa ADR-0006 (delegación inteligente). Eliminado hardcoding LLM, restaurada integración MasterOrchestrator y sistema de traducción de respuestas.",
        "testStrategy": "Validación 100% exitosa via validate_functionality_restoration.py - 11/11 funciones críticas restauradas, performance targets cumplidos (<1s directa, <3s delegada)",
        "status": "done",
        "dependencies": [18],
        "priority": "critical",
        "subtasks": [
          "Eliminar hardcoding ChatGoogleGenerativeAI → src.core.engine",
          "Restaurar delegación inteligente optimizada",
          "Restaurar integración MasterOrchestrator", 
          "Implementar threshold-based routing híbrido"
        ]
      },
      {
        "id": 20,
        "title": "Sistema Observabilidad y Trazabilidad LLM",
        "description": "Implementar sistema completo trazabilidad llamadas LLM, latencia y métricas performance",
        "details": "Crear LLMTracker para métricas: llamadas LLM por request, tiempo respuesta, tokens consumidos, costos. Integrar con LangSmith existente. Incluir middleware FastAPI para correlation IDs y métricas end-to-end. Dashboard tiempo real con alertas performance.",
        "testStrategy": "Tests unitarios LLMTracker, tests integración middleware, validación métricas Prometheus, tests alerting system",
        "status": "pending",
        "dependencies": [19],
        "priority": "high",
        "subtasks": [
          "LLMCallTracker con métricas tiempo real",
          "Middleware trazabilidad correlation_id",
          "Dashboard observabilidad Grafana/Prometheus",
          "Sistema alertas performance degradation"
        ]
      },
      {
        "id": 21,
        "title": "Performance Profiling y Optimización",
        "description": "Análisis profundo performance sistema completo con optimizaciones targeted",
        "details": "Profiling completo flujo Telegram → respuesta. Identificar bottlenecks: routing, delegation, LLM calls, vector search. Implementar optimizaciones: caching inteligente, connection pooling, async optimizations. Target <2s response time p95.",
        "testStrategy": "Load testing scenarios, memory profiling, latency analysis, performance regression tests",
        "status": "pending",
        "dependencies": [20],
        "priority": "high",
        "subtasks": [
          "Profile completo flujo end-to-end",
          "Optimización routing analyzer caching",
          "Connection pooling ChromaDB/Redis",
          "Async optimization specialist calls"
        ]
      },
      {
        "id": 22,
        "title": "Data Migration Script Completo",
        "description": "Script migración datos legacy a nueva arquitectura multi-tenant",
        "details": "Crear script robusto migración: collections legacy → user-specific collections, preservar metadata, migrar conversation history Redis. Incluir rollback, validación integridad datos, progress reporting. Dry-run mode para testing.",
        "testStrategy": "Tests migration script dry-run, tests rollback functionality, validation data integrity post-migration",
        "status": "pending",
        "dependencies": [21],
        "priority": "medium",
        "subtasks": [
          "Script migración ChromaDB collections",
          "Migración Redis conversation history",
          "Validación integridad datos",
          "Rollback mechanism completo"
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-25T18:27:06.912Z",
      "updated": "2025-09-04T15:30:00.000Z",
      "description": "Tasks for master context - ChatAgent functionality restoration completed (ADR-0009), observability tasks added. Total: 22 tasks, 11 completed (50%)."
    }
  }
}