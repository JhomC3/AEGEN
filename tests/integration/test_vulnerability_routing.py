"""Test de integración para flujo de detección de vulnerabilidad."""

from unittest.mock import AsyncMock, Mock, patch

import pytest

from src.core.routing_models import IntentType, RoutingDecision


class TestVulnerabilityRouting:
    """Valida el flujo completo: mensaje vulnerable → cbt_specialist."""

    @pytest.fixture
    def mock_state(self):
        """Estado mock con mensaje vulnerable."""
        event = Mock()
        event.event_type = "text"
        event.content = "Me siento muy mal, no sirvo para nada"
        event.user_id = "test_user"

        return {
            "event": event,
            "conversation_history": [],
            "payload": {},
        }

    @pytest.fixture
    def mock_cache(self):
        """Cache mock con especialistas disponibles."""
        cache = Mock()
        cache.has_routable_tools.return_value = True
        cache.get_tool_to_specialist_map.return_value = {
            "chat_tool": "chat_specialist",
            "cbt_tool": "cbt_specialist",
        }
        return cache

    def test_vulnerability_patterns_detected(self):
        """Valida que los patterns de TCC detecten vulnerabilidad."""
        from src.agents.orchestrator.routing.routing_patterns import IntentValidator

        validator = IntentValidator()

        # Casos que DEBEN detectarse como vulnerabilidad
        vulnerable_messages = [
            "Me siento muy mal",
            "No sirvo para nada",
            "Estoy solo y nadie me quiere",
            "Es mi culpa que todo salga mal",
            "No tiene sentido seguir intentando",
        ]

        for msg in vulnerable_messages:
            assert validator.has_clear_intent_evidence(
                msg, IntentType.VULNERABILITY
            ), f"No detectó vulnerabilidad en: '{msg}'"

    def test_trading_frustration_not_vulnerability(self):
        """Frustración por trading NO debe ser vulnerabilidad."""
        from src.agents.orchestrator.routing.routing_patterns import IntentValidator

        validator = IntentValidator()

        # Casos que NO deben ser vulnerabilidad (contexto trading)
        trading_messages = [
            "El trade no salió bien",
            "Me siento mal porque el stop loss saltó",
            "La operación fue un desastre, perdí 100 dólares",
        ]

        for msg in trading_messages:
            # Con negative patterns, estos NO deben matchear
            assert not validator.has_clear_intent_evidence(
                msg, IntentType.VULNERABILITY
            ), f"Detectó erróneamente vulnerabilidad en contexto trading: '{msg}'"

    @pytest.mark.asyncio
    async def test_3_level_routing_logic(self, mock_state, mock_cache):
        """Valida la lógica de 3 niveles en el router."""
        from src.agents.orchestrator.routing.enhanced_router import (
            EnhancedFunctionCallingRouter,
        )

        with patch(
            "src.agents.orchestrator.routing.enhanced_router.RoutingAnalyzer"
        ) as mock_analyzer_class:
            # Setup router
            router = EnhancedFunctionCallingRouter(mock_cache)
            analyzer_instance = mock_analyzer_class.return_value

            # CASO 1: Alta confianza (>85%) -> CBT Directo
            high_conf_decision = RoutingDecision(
                intent=IntentType.VULNERABILITY,
                confidence=0.9,
                target_specialist="cbt_specialist",
                requires_tools=True,
                next_actions=[],
            )
            analyzer_instance.analyze = AsyncMock(return_value=high_conf_decision)

            target = await router.route(mock_state)
            assert target == "cbt_specialist"
            assert (
                "depth_empathy"
                in mock_state["payload"]["routing_decision"]["next_actions"]
            )

            # CASO 2: Confianza moderada (60-85%) -> Clarificar
            mod_conf_decision = RoutingDecision(
                intent=IntentType.VULNERABILITY,
                confidence=0.7,
                target_specialist="cbt_specialist",
                requires_tools=True,
                next_actions=[],
            )
            analyzer_instance.analyze = AsyncMock(return_value=mod_conf_decision)

            target = await router.route(mock_state)
            assert target == "cbt_specialist"
            assert (
                "clarify_emotional_state"
                in mock_state["payload"]["routing_decision"]["next_actions"]
            )

            # CASO 3: Baja confianza (50-60%) -> Chat general
            low_conf_decision = RoutingDecision(
                intent=IntentType.VULNERABILITY,
                confidence=0.55,
                target_specialist="cbt_specialist",
                requires_tools=True,
                next_actions=[],
            )
            analyzer_instance.analyze = AsyncMock(return_value=low_conf_decision)

            target = await router.route(mock_state)
            assert target == "chat_specialist"
            assert (
                "monitor_emotional_cues"
                in mock_state["payload"]["routing_decision"]["next_actions"]
            )
